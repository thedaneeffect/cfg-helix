#!/usr/bin/env bash
set -euo pipefail

DEFAULT_GROUP="default"
SECRETS_REGISTRY_BASE="$HOME/.secrets"
CHUNK_SIZE=8000  # Leave headroom under 10k limit

# Helper: Get registry file for a group
get_registry_file() {
    local group="${1:-$DEFAULT_GROUP}"
    if [[ "$group" == "$DEFAULT_GROUP" ]]; then
        echo "$SECRETS_REGISTRY_BASE"
    else
        echo "$SECRETS_REGISTRY_BASE.$group"
    fi
}

# Helper: Format Bitwarden item name
bw_item_name() {
    local group="$1"
    local type="$2"  # metadata, chunk
    local chunk_num="${3:-}"  # optional chunk number

    if [[ "$type" == "chunk" && -n "$chunk_num" ]]; then
        echo "secrets:${group}:chunk:${chunk_num}"
    else
        echo "secrets:${group}:${type}"
    fi
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper: Print colored message
msg() {
    local color="$1"
    shift
    echo -e "${color}$*${NC}"
}

# Initialize registry for a group
init_registry() {
    local group="${1:-$DEFAULT_GROUP}"
    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]]; then
        touch "$registry"
        msg "$GREEN" "✓ Created secrets registry at $registry"
    fi
}

# Add a file or directory to the registry
cmd_add() {
    local group="$DEFAULT_GROUP"
    local paths=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -g|--group)
                group="$2"
                shift 2
                ;;
            *)
                paths+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#paths[@]} -eq 0 ]]; then
        msg "$RED" "✗ Usage: secrets add <path> [-g|--group GROUP]"
        msg "$YELLOW" "  Example: secrets add .ssh/id_rsa"
        msg "$YELLOW" "  Example: secrets add .ssh  (expands to all files in directory)"
        msg "$YELLOW" "  Example: secrets add .ssh/id_rsa -g github"
        return 1
    fi

    init_registry "$group"
    local registry=$(get_registry_file "$group")

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Using group: $group"

    for path in "${paths[@]}"; do
        # Expand ~ to $HOME
        path="${path/#\~/$HOME}"

        # Check if path exists
        if [[ ! -e "$path" ]]; then
            msg "$RED" "✗ Path does not exist: $path"
            continue
        fi

        # If it's a directory, recursively add all files
        if [[ -d "$path" ]]; then
            msg "$YELLOW" "→ Expanding directory: $path"
            local file_count=0

            # Find all files (not directories) and add them
            while IFS= read -r -d '' file; do
                local abs_path="$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"
                local rel_path="${abs_path#$HOME/}"

                # Check if already in registry
                if grep -qxF "$rel_path" "$registry" 2>/dev/null; then
                    msg "$YELLOW" "  ⊘ Already tracked: $rel_path"
                else
                    echo "$rel_path" >> "$registry"
                    msg "$GREEN" "  ✓ Added: $rel_path"
                    ((file_count++))
                fi
            done < <(find "$path" -type f -print0)

            msg "$GREEN" "✓ Added $file_count new files from directory"
        else
            # Single file
            local abs_path="$(cd "$(dirname "$path")" && pwd)/$(basename "$path")"
            local rel_path="${abs_path#$HOME/}"

            # Check if already in registry
            if grep -qxF "$rel_path" "$registry" 2>/dev/null; then
                msg "$YELLOW" "⊘ Already tracked: $rel_path"
            else
                echo "$rel_path" >> "$registry"
                msg "$GREEN" "✓ Added: $rel_path"
            fi
        fi
    done
}

# Remove a file or directory from the registry
cmd_remove() {
    local group="$DEFAULT_GROUP"
    local paths=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -g|--group)
                group="$2"
                shift 2
                ;;
            *)
                paths+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#paths[@]} -eq 0 ]]; then
        msg "$RED" "✗ Usage: secrets remove <path> [-g|--group GROUP]"
        return 1
    fi

    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]]; then
        msg "$RED" "✗ No secrets registry found for group: $group"
        return 1
    fi

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Using group: $group"

    for path in "${paths[@]}"; do
        # Normalize path
        local rel_path="${path#$HOME/}"
        rel_path="${rel_path#./}"

        if grep -qxF "$rel_path" "$registry"; then
            # Create temp file without the path
            grep -vxF "$rel_path" "$registry" > "$registry.tmp"
            mv "$registry.tmp" "$registry"
            msg "$GREEN" "✓ Removed: $rel_path"
        else
            msg "$YELLOW" "⊘ Not tracked: $rel_path"
        fi
    done
}

# List all tracked secrets
cmd_list() {
    local group="${1:-$DEFAULT_GROUP}"
    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]]; then
        msg "$YELLOW" "No secrets tracked for group: $group"
        msg "$YELLOW" "Use: secrets add <path> -g $group"
        return 0
    fi

    if [[ ! -s "$registry" ]]; then
        msg "$YELLOW" "No secrets tracked for group: $group"
        return 0
    fi

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Group: $group"
    msg "$GREEN" "Tracked secrets:"
    while IFS= read -r path; do
        # Skip empty lines and comments
        [[ -z "$path" || "$path" =~ ^# ]] && continue

        if [[ -e "$HOME/$path" ]]; then
            echo "  ✓ $path"
        else
            msg "$YELLOW" "  ✗ $path (missing)"
        fi
    done < "$registry"
}

# Show status of tracked vs existing files
cmd_status() {
    local group="${1:-$DEFAULT_GROUP}"
    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]] || [[ ! -s "$registry" ]]; then
        msg "$YELLOW" "No secrets tracked for group: $group"
        return 0
    fi

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Group: $group"

    local missing=0
    local exists=0

    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue

        if [[ -e "$HOME/$path" ]]; then
            ((exists++))
        else
            ((missing++))
            msg "$RED" "✗ Missing: $path"
        fi
    done < "$registry"

    echo ""
    msg "$GREEN" "✓ $exists files exist"
    [[ $missing -gt 0 ]] && msg "$RED" "✗ $missing files missing"
}

# Ensure Bitwarden is ready
ensure_bitwarden() {
    if ! command -v bw >/dev/null 2>&1; then
        msg "$RED" "✗ Bitwarden CLI not installed"
        msg "$YELLOW" "  Install: brew install bitwarden-cli"
        return 1
    fi

    # Check if logged in
    if ! bw login --check &>/dev/null; then
        msg "$YELLOW" "→ Please login to Bitwarden:"
        read -p "  Email: " email

        # Login and capture session key from output
        local login_output=$(mktemp)
        if bw login "$email" 2>&1 | tee "$login_output"; then
            # Try to extract session key from login output
            local session_key=$(grep -oE 'BW_SESSION="[^"]+' "$login_output" | head -1 | cut -d'"' -f2)
            rm -f "$login_output"

            # If we got a session key from login, use it
            if [[ -n "$session_key" ]]; then
                export BW_SESSION="$session_key"
                msg "$GREEN" "✓ Session key exported (valid for this session)"
                msg "$YELLOW" "  To persist in your shell, run:"
                msg "$YELLOW" "  export BW_SESSION=\"$session_key\""
            else
                # Otherwise, unlock to get session key
                msg "$YELLOW" "→ Unlocking vault..."
                export BW_SESSION="$(bw unlock --raw)" || return 1
                msg "$GREEN" "✓ Session key exported (valid for this session)"
                msg "$YELLOW" "  To persist in your shell, run:"
                msg "$YELLOW" "  export BW_SESSION=\"$BW_SESSION\""
            fi
        else
            rm -f "$login_output"
            return 1
        fi
    fi

    # Unlock if needed (already logged in but no session)
    if [[ -z "${BW_SESSION:-}" ]]; then
        msg "$YELLOW" "→ Unlocking Bitwarden vault..."
        export BW_SESSION="$(bw unlock --raw)" || return 1
        msg "$GREEN" "✓ Vault unlocked (valid for this session)"
        msg "$YELLOW" "  To persist in your shell, run:"
        msg "$YELLOW" "  export BW_SESSION=\"$BW_SESSION\""
    fi

    # Verify session is valid
    if ! bw unlock --check --session "$BW_SESSION" &>/dev/null; then
        msg "$YELLOW" "→ Session invalid or expired, unlocking vault..."
        # Clear old session before unlocking
        unset BW_SESSION
        export BW_SESSION="$(bw unlock --raw)" || {
            msg "$RED" "✗ Failed to unlock vault"
            return 1
        }
        msg "$GREEN" "✓ Vault unlocked"
        msg "$YELLOW" "  To persist in your shell, run:"
        msg "$YELLOW" "  export BW_SESSION=\"$BW_SESSION\""
    fi
}

# Get or create a Bitwarden item by name
get_or_create_item() {
    local item_name="$1"
    local item_id=$(bw list items --session "$BW_SESSION" 2>/dev/null | jq -r --arg name "$item_name" '.[] | select(.name == $name) | .id')

    if [[ -z "$item_id" ]]; then
        # Create the item and capture output
        local create_output=$(bw get template item | \
            jq '.type = 2 | .name = "'"$item_name"'" | .secureNote.type = 0' | \
            bw encode | bw create item --session "$BW_SESSION" 2>&1)

        # Extract item ID from output
        item_id=$(echo "$create_output" | jq -r '.id' 2>/dev/null)

        if [[ -z "$item_id" || "$item_id" == "null" ]]; then
            msg "$RED" "✗ Failed to create Bitwarden item: $item_name"
            msg "$RED" "  Error: $create_output"
            return 1
        fi
    fi

    echo "$item_id"
}

# Push secrets to Bitwarden
cmd_push() {
    local group="${1:-$DEFAULT_GROUP}"
    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]] || [[ ! -s "$registry" ]]; then
        msg "$RED" "✗ No secrets to push for group: $group"
        msg "$YELLOW" "  Add secrets with: secrets add <path> -g $group"
        return 1
    fi

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Using group: $group"

    # Verify all files exist
    local missing=0
    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue
        if [[ ! -e "$HOME/$path" ]]; then
            msg "$RED" "✗ Missing file: $path"
            ((missing++))
        fi
    done < "$registry"

    if [[ $missing -gt 0 ]]; then
        msg "$RED" "✗ Cannot push: $missing files missing"
        return 1
    fi

    ensure_bitwarden || return 1

    msg "$GREEN" "→ Creating tarball..."

    # Create tarball with all tracked files
    local temp_tar=$(mktemp /tmp/secrets.XXXXXX.tar.gz)
    trap "rm -f '$temp_tar'" EXIT

    # Read paths into array for tar
    local paths=()
    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue
        paths+=("$path")
    done < "$registry"

    # Create tar from home directory
    tar czf "$temp_tar" -C "$HOME" "${paths[@]}" 2>/dev/null || {
        msg "$RED" "✗ Failed to create tarball"
        return 1
    }

    msg "$GREEN" "→ Encoding and chunking secrets..."

    # Base64 encode the tarball
    local base64_data=$(base64 < "$temp_tar" | tr -d '\n')
    local data_length=${#base64_data}
    local num_chunks=$(( (data_length + CHUNK_SIZE - 1) / CHUNK_SIZE ))

    msg "$GREEN" "  Data size: $data_length bytes"
    msg "$GREEN" "  Chunks needed: $num_chunks"

    # Delete old chunks if they exist
    msg "$YELLOW" "  Cleaning up old chunks..."
    local old_items=$(bw list items --session "$BW_SESSION" 2>/dev/null | \
        jq -r --arg prefix "secrets:${group}:chunk:" '.[] | select(.name | startswith($prefix)) | .id')

    if [[ -n "$old_items" ]]; then
        while read -r old_id; do
            [[ -n "$old_id" ]] && bw delete item "$old_id" --session "$BW_SESSION" &>/dev/null
        done <<< "$old_items"
    fi

    # Create chunks
    msg "$YELLOW" "  Uploading chunks to Bitwarden..."
    for ((i=0; i<num_chunks; i++)); do
        local start=$((i * CHUNK_SIZE))
        local chunk="${base64_data:$start:$CHUNK_SIZE}"
        local chunk_name=$(bw_item_name "$group" "chunk" "$i")

        # Create chunk item
        local chunk_id=$(get_or_create_item "$chunk_name")

        # Store chunk data
        bw get item "$chunk_id" --session "$BW_SESSION" | \
            jq --arg data "$chunk" '.notes = $data' | \
            bw encode | \
            bw edit item "$chunk_id" --session "$BW_SESSION" &>/dev/null

        msg "$GREEN" "    ✓ Chunk $((i+1))/$num_chunks"
    done

    # Create/update metadata item
    msg "$YELLOW" "  Storing metadata..."
    local metadata_name=$(bw_item_name "$group" "metadata")
    local metadata_id=$(get_or_create_item "$metadata_name")
    local metadata_json=$(jq -n --arg count "$num_chunks" '{chunks: ($count | tonumber)}')

    bw get item "$metadata_id" --session "$BW_SESSION" | \
        jq --argjson meta "$metadata_json" '.notes = ($meta | tostring)' | \
        bw encode | \
        bw edit item "$metadata_id" --session "$BW_SESSION" &>/dev/null

    # Sync
    msg "$YELLOW" "  Syncing..."
    bw sync --session "$BW_SESSION" &>/dev/null

    msg "$GREEN" "✓ Secrets pushed to Bitwarden"
    msg "$GREEN" "  Group: $group"
    msg "$GREEN" "  Files: ${#paths[@]}"
    msg "$GREEN" "  Chunks: $num_chunks"
    msg "$GREEN" "  Total size: $(du -h "$temp_tar" | cut -f1)"
}

# Pull secrets from Bitwarden
cmd_pull() {
    local group="${1:-$DEFAULT_GROUP}"

    ensure_bitwarden || return 1

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Using group: $group"

    # Sync with server first to get latest data
    msg "$GREEN" "→ Syncing with Bitwarden..."
    bw sync --session "$BW_SESSION" &>/dev/null

    msg "$GREEN" "→ Downloading metadata from Bitwarden..."

    # Get metadata item
    local metadata_name=$(bw_item_name "$group" "metadata")
    local metadata_data=$(bw get item "$metadata_name" --session "$BW_SESSION" 2>&1)

    if [[ $? -ne 0 ]]; then
        msg "$RED" "✗ No secrets found in Bitwarden for group: $group"
        msg "$YELLOW" "  Push secrets first with: secrets push $group"
        return 1
    fi

    # Parse metadata to get chunk count
    local metadata_json=$(echo "$metadata_data" | jq -r '.notes // empty')
    local num_chunks=$(echo "$metadata_json" | jq -r '.chunks // empty')

    if [[ -z "$num_chunks" || "$num_chunks" == "null" ]]; then
        msg "$RED" "✗ Invalid metadata in Bitwarden for group: $group"
        msg "$YELLOW" "  Try pushing secrets again with: secrets push $group"
        return 1
    fi

    msg "$GREEN" "  Chunks to download: $num_chunks"

    # Download and concatenate all chunks
    msg "$YELLOW" "  Downloading chunks..."
    local base64_data=""
    for ((i=0; i<num_chunks; i++)); do
        local chunk_name=$(bw_item_name "$group" "chunk" "$i")
        local chunk_data=$(bw get item "$chunk_name" --session "$BW_SESSION" 2>/dev/null | jq -r '.notes // empty')

        if [[ -z "$chunk_data" ]]; then
            msg "$RED" "✗ Failed to download chunk $i"
            return 1
        fi

        base64_data="${base64_data}${chunk_data}"
        msg "$GREEN" "    ✓ Chunk $((i+1))/$num_chunks"
    done

    # Decode and extract
    msg "$GREEN" "→ Extracting secrets..."
    echo "$base64_data" | base64 -d | tar xzf - -C "$HOME" || {
        msg "$RED" "✗ Failed to extract secrets"
        return 1
    }

    # Count files from registry if it exists
    local registry=$(get_registry_file "$group")
    local count=0
    if [[ -f "$registry" ]]; then
        count=$(grep -v '^#' "$registry" | grep -v '^$' | wc -l | tr -d ' ')
    fi

    msg "$GREEN" "✓ Secrets pulled from Bitwarden"
    msg "$GREEN" "  Group: $group"
    [[ $count -gt 0 ]] && msg "$GREEN" "  Files restored: $count"
}

# List available groups in Bitwarden
cmd_groups() {
    ensure_bitwarden || return 1

    # Sync with server first to get latest data
    msg "$GREEN" "→ Syncing with Bitwarden..."
    bw sync --session "$BW_SESSION" &>/dev/null

    msg "$GREEN" "→ Scanning Bitwarden for secret groups..."

    # Find all metadata items (secrets:*:metadata)
    local groups=$(bw list items --session "$BW_SESSION" 2>/dev/null | \
        jq -r '.[] | select(.name | test("^secrets:.+:metadata$")) | .name' | \
        sed 's/^secrets://; s/:metadata$//')

    if [[ -z "$groups" ]]; then
        msg "$YELLOW" "No secret groups found in Bitwarden"
        msg "$YELLOW" "  Push your first group with: secrets push"
        return 0
    fi

    msg "$GREEN" "Available secret groups:"
    while read -r group; do
        [[ -z "$group" ]] && continue
        local registry=$(get_registry_file "$group")
        if [[ -f "$registry" ]]; then
            local file_count=$(grep -v '^#' "$registry" | grep -v '^$' | wc -l | tr -d ' ')
            echo "  ✓ $group ($file_count files tracked locally)"
        else
            echo "  ⊙ $group (not pulled yet)"
        fi
    done <<< "$groups"
}

# Show help
cmd_help() {
    cat << 'EOF'
secrets - Manage dotfiles secrets with Bitwarden (with named groups)

Usage:
  secrets add <path> [-g GROUP]     Add files/directories to group registry
                                    (directories expanded to individual files)
  secrets remove <path> [-g GROUP]  Remove from group registry
  secrets list [GROUP]              Show tracked files in group
  secrets status [GROUP]            Show status of tracked files in group
  secrets push [GROUP]              Upload group to Bitwarden
  secrets pull [GROUP]              Download and restore group from Bitwarden
  secrets groups                    List all available groups in Bitwarden
  secrets help                      Show this help message

Groups:
  - Default group: "default" (used when no -g flag specified)
  - Named groups: Organize secrets by purpose (e.g., github, work, personal)
  - Each group has its own registry: ~/.secrets, ~/.secrets.github, etc.
  - Groups are independent - files can be in multiple groups

Examples:
  # Default group
  secrets add ~/.ssh/id_rsa ~/.env       # Add to default group
  secrets push                           # Push default group
  secrets pull                           # Pull default group

  # Named groups
  secrets add ~/.ssh/github_rsa -g github    # Add to github group
  secrets add ~/.aws/credentials -g work     # Add to work group
  secrets push github                        # Push github group only
  secrets pull work                          # Pull work group only
  secrets list github                        # List github group files
  secrets groups                             # See all available groups

  # Organization
  secrets add ~/.ssh -g github          # Add all SSH files to github group
  secrets remove ~/.ssh/known_hosts -g github  # Remove specific file

Bitwarden storage (per group):
  - Metadata: "secrets:{group}:metadata"
  - Chunks: "secrets:{group}:chunk:0", "secrets:{group}:chunk:1", etc.
  - Works with free Bitwarden tier (10k char limit per note)
EOF
}

# Main command router
main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        add)
            cmd_add "$@"
            ;;
        remove|rm)
            cmd_remove "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        status|st)
            cmd_status "$@"
            ;;
        push)
            cmd_push "$@"
            ;;
        pull)
            cmd_pull "$@"
            ;;
        groups)
            cmd_groups "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            msg "$RED" "✗ Unknown command: $cmd"
            echo ""
            cmd_help
            return 1
            ;;
    esac
}

main "$@"
