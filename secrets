#!/usr/bin/env bash
set -euo pipefail

DEFAULT_GROUP="default"
SECRETS_REGISTRY_BASE="$HOME/.secrets"

# Worker configuration
SECRETS_URL="${SECRETS_URL:-}"
SECRETS_URL="${SECRETS_URL%/}"  # Remove trailing slash if present
SECRETS_PASSPHRASE="${SECRETS_PASSPHRASE:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper: Print colored message
msg() {
    local color="$1"
    shift
    echo -e "${color}$*${NC}"
}

# Helper: Get registry file for a group
get_registry_file() {
    local group="${1:-$DEFAULT_GROUP}"
    if [[ "$group" == "$DEFAULT_GROUP" ]]; then
        echo "$SECRETS_REGISTRY_BASE"
    else
        echo "$SECRETS_REGISTRY_BASE.$group"
    fi
}

# Initialize registry for a group
init_registry() {
    local group="${1:-$DEFAULT_GROUP}"
    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]]; then
        touch "$registry"
        msg "$GREEN" "✓ Created secrets registry at $registry"
    fi
}

# Add a file or directory to the registry
cmd_add() {
    local group="$DEFAULT_GROUP"
    local paths=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -g|--group)
                group="$2"
                shift 2
                ;;
            *)
                paths+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#paths[@]} -eq 0 ]]; then
        msg "$RED" "✗ Usage: secrets add <path> [-g|--group GROUP]"
        msg "$YELLOW" "  Example: secrets add .ssh/id_rsa"
        msg "$YELLOW" "  Example: secrets add .ssh  (expands to all files in directory)"
        msg "$YELLOW" "  Example: secrets add .ssh/id_rsa -g github"
        return 1
    fi

    init_registry "$group"
    local registry=$(get_registry_file "$group")

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Using group: $group"

    for path in "${paths[@]}"; do
        # Expand ~ to $HOME
        path="${path/#\~/$HOME}"

        # Check if path exists
        if [[ ! -e "$path" ]]; then
            msg "$RED" "✗ Path does not exist: $path"
            continue
        fi

        # If it's a directory, recursively add all files
        if [[ -d "$path" ]]; then
            msg "$YELLOW" "→ Expanding directory: $path"
            local file_count=0

            # Find all files (not directories) and add them
            while IFS= read -r -d '' file; do
                local abs_path="$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"
                local rel_path="${abs_path#$HOME/}"

                # Check if already in registry
                if grep -qxF "$rel_path" "$registry" 2>/dev/null; then
                    msg "$YELLOW" "  ⊘ Already tracked: $rel_path"
                else
                    echo "$rel_path" >> "$registry"
                    msg "$GREEN" "  ✓ Added: $rel_path"
                    ((file_count++))
                fi
            done < <(find "$path" -type f -print0)

            msg "$GREEN" "✓ Added $file_count new files from directory"
        else
            # Single file
            local abs_path="$(cd "$(dirname "$path")" && pwd)/$(basename "$path")"
            local rel_path="${abs_path#$HOME/}"

            # Check if already in registry
            if grep -qxF "$rel_path" "$registry" 2>/dev/null; then
                msg "$YELLOW" "⊘ Already tracked: $rel_path"
            else
                echo "$rel_path" >> "$registry"
                msg "$GREEN" "✓ Added: $rel_path"
            fi
        fi
    done
}

# Remove a file from the registry
cmd_remove() {
    local group="$DEFAULT_GROUP"
    local paths=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -g|--group)
                group="$2"
                shift 2
                ;;
            *)
                paths+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#paths[@]} -eq 0 ]]; then
        msg "$RED" "✗ Usage: secrets remove <path> [-g|--group GROUP]"
        return 1
    fi

    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]]; then
        msg "$RED" "✗ No secrets registry found for group: $group"
        return 1
    fi

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Using group: $group"

    for path in "${paths[@]}"; do
        # Normalize path
        local rel_path="${path#$HOME/}"
        rel_path="${rel_path#./}"

        if grep -qxF "$rel_path" "$registry"; then
            # Create temp file without the path
            grep -vxF "$rel_path" "$registry" > "$registry.tmp"
            mv "$registry.tmp" "$registry"
            msg "$GREEN" "✓ Removed: $rel_path"
        else
            msg "$YELLOW" "⊘ Not tracked: $rel_path"
        fi
    done
}

# List all tracked secrets
cmd_list() {
    local group="${1:-$DEFAULT_GROUP}"
    local registry=$(get_registry_file "$group")

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Group: $group"

    # Show locally tracked files
    if [[ ! -f "$registry" ]] || [[ ! -s "$registry" ]]; then
        msg "$YELLOW" "No secrets tracked locally for group: $group"
        msg "$YELLOW" "Use: secrets add <path> -g $group"
    else
        msg "$GREEN" "Locally tracked secrets:"
        while IFS= read -r path; do
            # Skip empty lines and comments
            [[ -z "$path" || "$path" =~ ^# ]] && continue

            if [[ -e "$HOME/$path" ]]; then
                echo "  ✓ $path"
            else
                msg "$YELLOW" "  ✗ $path (missing)"
            fi
        done < "$registry"
    fi

    echo ""

    # Show remote group metadata
    if [[ -n "$SECRETS_URL" ]] && [[ -n "$SECRETS_PASSPHRASE" ]]; then
        msg "$GREEN" "Remote secrets (in worker):"

        # Fetch all metadata
        local http_code=$(curl -s -w "%{http_code}" \
            -H "Authorization: Bearer $SECRETS_PASSPHRASE" \
            -o /tmp/metadata.json \
            "$SECRETS_URL/metadata")

        if [[ "$http_code" == "200" ]]; then
            # Check if this group has metadata
            local has_group=$(jq -r "has(\"$group\")" /tmp/metadata.json 2>/dev/null)

            if [[ "$has_group" == "true" ]]; then
                local files=$(jq -r ".\"$group\".files[]" /tmp/metadata.json 2>/dev/null)
                local size=$(jq -r ".\"$group\".size" /tmp/metadata.json 2>/dev/null)
                local uploaded=$(jq -r ".\"$group\".uploaded" /tmp/metadata.json 2>/dev/null)

                if [[ -n "$files" ]]; then
                    echo "$files" | while read -r file; do
                        echo "  ✓ $file"
                    done
                    echo ""
                    msg "$YELLOW" "  Size: $size | Uploaded: $uploaded"
                else
                    msg "$YELLOW" "  (no files)"
                fi
            else
                msg "$YELLOW" "  (no secrets in worker for this group)"
            fi
            rm -f /tmp/metadata.json
        elif [[ "$http_code" == "401" ]]; then
            msg "$RED" "  (unauthorized - check SECRETS_PASSPHRASE)"
        else
            msg "$YELLOW" "  (failed to fetch metadata: HTTP $http_code)"
        fi
    else
        msg "$YELLOW" "Remote secrets: (SECRETS_URL/SECRETS_PASSPHRASE not configured)"
    fi
}

# Show status of tracked vs existing files
cmd_status() {
    local group="${1:-$DEFAULT_GROUP}"
    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]] || [[ ! -s "$registry" ]]; then
        msg "$YELLOW" "No secrets tracked for group: $group"
        return 0
    fi

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Group: $group"

    local missing=0
    local exists=0

    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue

        if [[ -e "$HOME/$path" ]]; then
            ((exists++))
        else
            ((missing++))
            msg "$RED" "✗ Missing: $path"
        fi
    done < "$registry"

    echo ""
    msg "$GREEN" "✓ $exists files exist"
    [[ $missing -gt 0 ]] && msg "$RED" "✗ $missing files missing"
}

# Ensure worker backend is configured
ensure_worker() {
    if [[ -z "$SECRETS_URL" ]]; then
        msg "$RED" "✗ SECRETS_URL not set"
        msg "$YELLOW" "  Set: export SECRETS_URL=\"https://your-worker.workers.dev\""
        return 1
    fi

    if [[ -z "$SECRETS_PASSPHRASE" ]]; then
        msg "$RED" "✗ SECRETS_PASSPHRASE not set"
        msg "$YELLOW" "  Set: export SECRETS_PASSPHRASE=\"your-passphrase\""
        return 1
    fi
}

# Push secrets to worker
cmd_push() {
    local group="${1:-$DEFAULT_GROUP}"
    local registry=$(get_registry_file "$group")

    if [[ ! -f "$registry" ]] || [[ ! -s "$registry" ]]; then
        msg "$RED" "✗ No secrets to push for group: $group"
        msg "$YELLOW" "  Add secrets with: secrets add <path> -g $group"
        return 1
    fi

    ensure_worker || return 1

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Using group: $group"

    # Verify all files exist
    local missing=0
    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue
        if [[ ! -e "$HOME/$path" ]]; then
            msg "$RED" "✗ Missing file: $path"
            ((missing++))
        fi
    done < "$registry"

    if [[ $missing -gt 0 ]]; then
        msg "$RED" "✗ Cannot push: $missing files missing"
        return 1
    fi

    # Create tarball
    msg "$YELLOW" "→ Creating tarball..."
    local tarball=$(mktemp)
    tar czf "$tarball" -C "$HOME" -T "$registry" \
        --exclude='._*' \
        --exclude='.DS_Store' \
        2>/dev/null || {
        msg "$RED" "✗ Failed to create tarball"
        rm -f "$tarball"
        return 1
    }

    local tarball_size=$(du -h "$tarball" | cut -f1)

    # Base64 encode
    msg "$YELLOW" "→ Encoding and uploading ($tarball_size)..."
    local base64_data=$(base64 < "$tarball")

    # Build file list for metadata
    local file_array="["
    local first=true
    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue
        if [[ "$first" == "true" ]]; then
            file_array+="\"$path\""
            first=false
        else
            file_array+=",\"$path\""
        fi
    done < "$registry"
    file_array+="]"

    rm -f "$tarball"

    # Upload to worker with metadata
    local response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: Bearer $SECRETS_PASSPHRASE" \
        -H "Content-Type: text/plain" \
        -H "X-Files: $file_array" \
        -H "X-Size: $tarball_size" \
        --data "$base64_data" \
        "$SECRETS_URL/secrets/$group")

    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    if [[ "$http_code" == "200" ]]; then
        # Count files
        local file_count=0
        while IFS= read -r path; do
            [[ -z "$path" || "$path" =~ ^# ]] && continue
            ((file_count++))
        done < "$registry"

        msg "$GREEN" "✓ Secrets pushed to worker"
        msg "$GREEN" "  Group: $group"
        msg "$GREEN" "  Files: $file_count"
        msg "$GREEN" "  Size: $tarball_size"
        echo ""
        msg "$GREEN" "Files pushed:"
        while IFS= read -r path; do
            [[ -z "$path" || "$path" =~ ^# ]] && continue
            echo "  - $path"
        done < "$registry"
        return 0
    else
        msg "$RED" "✗ Failed to push secrets (HTTP $http_code)"
        [[ -n "$body" ]] && msg "$RED" "  Error: $body"
        return 1
    fi
}

# Pull secrets from worker
cmd_pull() {
    local group="${1:-$DEFAULT_GROUP}"

    ensure_worker || return 1

    [[ "$group" != "$DEFAULT_GROUP" ]] && msg "$YELLOW" "→ Using group: $group"

    # Download from worker
    msg "$YELLOW" "→ Downloading from worker..."
    local base64_file=$(mktemp)
    local http_code=$(curl -s -w "%{http_code}" \
        -H "Authorization: Bearer $SECRETS_PASSPHRASE" \
        -o "$base64_file" \
        "$SECRETS_URL/secrets/$group")

    if [[ "$http_code" == "200" ]]; then
        msg "$YELLOW" "→ Decoding and extracting secrets..."
        local tarball=$(mktemp)
        if base64 -d < "$base64_file" > "$tarball" 2>/dev/null; then
            rm -f "$base64_file"
            local tarball_size=$(du -h "$tarball" | cut -f1)

            # List contents before extraction
            local extracted_files=$(tar tzf "$tarball" 2>/dev/null | wc -l | tr -d ' ')
            local file_list=$(tar tzf "$tarball" 2>/dev/null)

            if tar xzf "$tarball" -C "$HOME" 2>/dev/null; then
                rm -f "$tarball"

                msg "$GREEN" "✓ Secrets pulled from worker"
                msg "$GREEN" "  Group: $group"
                msg "$GREEN" "  Files: $extracted_files"
                msg "$GREEN" "  Size: $tarball_size"
                echo ""
                msg "$GREEN" "Files restored:"
                echo "$file_list" | while read -r file; do
                    echo "  - $file"
                done
                return 0
            else
                rm -f "$tarball"
                msg "$RED" "✗ Failed to extract tarball"
                return 1
            fi
        else
            rm -f "$base64_file"
            msg "$RED" "✗ Failed to decode base64"
            return 1
        fi
    elif [[ "$http_code" == "404" ]]; then
        rm -f "$tarball"
        msg "$YELLOW" "⊘ No secrets found for group: $group"
        msg "$YELLOW" "  Push first with: secrets push $group"
        return 1
    elif [[ "$http_code" == "401" ]]; then
        rm -f "$tarball"
        msg "$RED" "✗ Unauthorized - check SECRETS_PASSPHRASE"
        return 1
    else
        rm -f "$tarball"
        msg "$RED" "✗ Failed to pull secrets (HTTP $http_code)"
        return 1
    fi
}

# List groups from worker
cmd_groups() {
    ensure_worker || return 1

    msg "$YELLOW" "→ Fetching groups from worker..."
    local http_code=$(curl -s -w "%{http_code}" \
        -H "Authorization: Bearer $SECRETS_PASSPHRASE" \
        -o /tmp/metadata.json \
        "$SECRETS_URL/metadata")

    if [[ "$http_code" == "200" ]]; then
        local groups=$(jq -r 'keys[]' /tmp/metadata.json 2>/dev/null)
        rm -f /tmp/metadata.json

        if [[ -z "$groups" ]]; then
            msg "$YELLOW" "No groups found in worker"
            msg "$YELLOW" "  Push a group with: secrets push [GROUP]"
        else
            msg "$GREEN" "Available groups in worker:"
            echo "$groups" | while read -r group; do
                echo "  - $group"
            done
        fi
        return 0
    elif [[ "$http_code" == "401" ]]; then
        msg "$RED" "✗ Unauthorized - check SECRETS_PASSPHRASE"
        return 1
    else
        msg "$RED" "✗ Failed to list groups (HTTP $http_code)"
        return 1
    fi
}

# Show help message
cmd_help() {
    cat << 'EOF'
secrets - Manage dotfiles secrets with Cloudflare Workers

Usage:
  secrets add <path> [-g GROUP]     Add files/directories to group registry
                                    (directories expanded to individual files)
  secrets remove <path> [-g GROUP]  Remove from group registry
  secrets list [GROUP]              Show tracked files in group
  secrets status [GROUP]            Show status of tracked files in group
  secrets push [GROUP]              Upload group to worker
  secrets pull [GROUP]              Download and restore group from worker
  secrets groups                    List all available groups in worker
  secrets help                      Show this help message

Configuration:
  export SECRETS_URL="https://your-worker.workers.dev"
  export SECRETS_PASSPHRASE="your-secret-passphrase"

Groups:
  - Default group: "default" (used when no -g flag specified)
  - Named groups: Organize secrets by purpose (e.g., github, work, personal)
  - Each group has its own registry: ~/.secrets, ~/.secrets.github, etc.
  - Groups are independent - files can be in multiple groups

Examples:
  # Setup
  export SECRETS_URL="https://secrets.your-subdomain.workers.dev"
  export SECRETS_PASSPHRASE="my-super-secret-passphrase"

  # Default group
  secrets add ~/.ssh/id_rsa ~/.env       # Add to default group
  secrets push                           # Push default group
  secrets pull                           # Pull default group

  # Named groups
  secrets add ~/.ssh/github_rsa -g github    # Add to github group
  secrets add ~/.aws/credentials -g work     # Add to work group
  secrets push github                        # Push github group only
  secrets pull work                          # Pull work group only
  secrets list github                        # List github group files
  secrets groups                             # See all available groups

  # Organization
  secrets add ~/.ssh -g github          # Add all SSH files to github group
  secrets remove ~/.ssh/known_hosts -g github  # Remove specific file

Worker storage:
  - Stored in Cloudflare KV
  - 25MB per group limit
  - Free tier: 1GB storage, 100k reads/day, 1k writes/day
  - Deploy from: worker/ directory in this repo
EOF
}

# Main command router
main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        add)
            cmd_add "$@"
            ;;
        remove|rm)
            cmd_remove "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        status|st)
            cmd_status "$@"
            ;;
        push)
            cmd_push "$@"
            ;;
        pull)
            cmd_pull "$@"
            ;;
        groups)
            cmd_groups "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            msg "$RED" "✗ Unknown command: $cmd"
            echo ""
            cmd_help
            return 1
            ;;
    esac
}

main "$@"
