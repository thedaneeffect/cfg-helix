#!/usr/bin/env bash
set -euo pipefail

SECRETS_REGISTRY="$HOME/.secrets"
BW_ITEM_NAME_PREFIX="Dotfiles Secrets"
BW_METADATA_ITEM="Dotfiles Secrets - Metadata"
CHUNK_SIZE=8000  # Leave headroom under 10k limit

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper: Print colored message
msg() {
    local color="$1"
    shift
    echo -e "${color}$*${NC}"
}

# Initialize registry if it doesn't exist
init_registry() {
    if [[ ! -f "$SECRETS_REGISTRY" ]]; then
        touch "$SECRETS_REGISTRY"
        msg "$GREEN" "✓ Created secrets registry at $SECRETS_REGISTRY"
    fi
}

# Add a file or directory to the registry
cmd_add() {
    init_registry

    if [[ $# -eq 0 ]]; then
        msg "$RED" "✗ Usage: secrets add <path>"
        msg "$YELLOW" "  Example: secrets add .ssh/id_rsa"
        return 1
    fi

    for path in "$@"; do
        # Convert to relative path from home
        local abs_path="$(cd "$(dirname "$path")" 2>/dev/null && pwd)/$(basename "$path")" || {
            msg "$RED" "✗ Path does not exist: $path"
            continue
        }

        # Make relative to home
        local rel_path="${abs_path#$HOME/}"

        # Check if already in registry
        if grep -qxF "$rel_path" "$SECRETS_REGISTRY" 2>/dev/null; then
            msg "$YELLOW" "⊘ Already tracked: $rel_path"
        else
            echo "$rel_path" >> "$SECRETS_REGISTRY"
            msg "$GREEN" "✓ Added: $rel_path"
        fi
    done
}

# Remove a file or directory from the registry
cmd_remove() {
    if [[ $# -eq 0 ]]; then
        msg "$RED" "✗ Usage: secrets remove <path>"
        return 1
    fi

    if [[ ! -f "$SECRETS_REGISTRY" ]]; then
        msg "$RED" "✗ No secrets registry found"
        return 1
    fi

    for path in "$@"; do
        # Normalize path
        local rel_path="${path#$HOME/}"
        rel_path="${rel_path#./}"

        if grep -qxF "$rel_path" "$SECRETS_REGISTRY"; then
            # Create temp file without the path
            grep -vxF "$rel_path" "$SECRETS_REGISTRY" > "$SECRETS_REGISTRY.tmp"
            mv "$SECRETS_REGISTRY.tmp" "$SECRETS_REGISTRY"
            msg "$GREEN" "✓ Removed: $rel_path"
        else
            msg "$YELLOW" "⊘ Not tracked: $rel_path"
        fi
    done
}

# List all tracked secrets
cmd_list() {
    if [[ ! -f "$SECRETS_REGISTRY" ]]; then
        msg "$YELLOW" "No secrets tracked yet"
        msg "$YELLOW" "Use: secrets add <path>"
        return 0
    fi

    if [[ ! -s "$SECRETS_REGISTRY" ]]; then
        msg "$YELLOW" "No secrets tracked yet"
        return 0
    fi

    msg "$GREEN" "Tracked secrets:"
    while IFS= read -r path; do
        # Skip empty lines and comments
        [[ -z "$path" || "$path" =~ ^# ]] && continue

        if [[ -e "$HOME/$path" ]]; then
            echo "  ✓ $path"
        else
            msg "$YELLOW" "  ✗ $path (missing)"
        fi
    done < "$SECRETS_REGISTRY"
}

# Show status of tracked vs existing files
cmd_status() {
    if [[ ! -f "$SECRETS_REGISTRY" ]] || [[ ! -s "$SECRETS_REGISTRY" ]]; then
        msg "$YELLOW" "No secrets tracked"
        return 0
    fi

    local missing=0
    local exists=0

    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue

        if [[ -e "$HOME/$path" ]]; then
            ((exists++))
        else
            ((missing++))
            msg "$RED" "✗ Missing: $path"
        fi
    done < "$SECRETS_REGISTRY"

    echo ""
    msg "$GREEN" "✓ $exists files exist"
    [[ $missing -gt 0 ]] && msg "$RED" "✗ $missing files missing"
}

# Ensure Bitwarden is ready
ensure_bitwarden() {
    if ! command -v bw >/dev/null 2>&1; then
        msg "$RED" "✗ Bitwarden CLI not installed"
        msg "$YELLOW" "  Install: brew install bitwarden-cli"
        return 1
    fi

    # Check if logged in
    if ! bw login --check &>/dev/null; then
        msg "$YELLOW" "→ Please login to Bitwarden:"
        read -p "  Email: " email

        # Login and capture session key from output
        local login_output=$(mktemp)
        if bw login "$email" 2>&1 | tee "$login_output"; then
            # Try to extract session key from login output
            local session_key=$(grep -oE 'BW_SESSION="[^"]+' "$login_output" | head -1 | cut -d'"' -f2)
            rm -f "$login_output"

            # If we got a session key from login, use it
            if [[ -n "$session_key" ]]; then
                export BW_SESSION="$session_key"
                msg "$GREEN" "✓ Session key exported (valid for this session)"
                msg "$YELLOW" "  To persist in your shell, run:"
                msg "$YELLOW" "  export BW_SESSION=\"$session_key\""
            else
                # Otherwise, unlock to get session key
                msg "$YELLOW" "→ Unlocking vault..."
                export BW_SESSION="$(bw unlock --raw)" || return 1
                msg "$GREEN" "✓ Session key exported (valid for this session)"
                msg "$YELLOW" "  To persist in your shell, run:"
                msg "$YELLOW" "  export BW_SESSION=\"$BW_SESSION\""
            fi
        else
            rm -f "$login_output"
            return 1
        fi
    fi

    # Unlock if needed (already logged in but no session)
    if [[ -z "${BW_SESSION:-}" ]]; then
        msg "$YELLOW" "→ Unlocking Bitwarden vault..."
        export BW_SESSION="$(bw unlock --raw)" || return 1
        msg "$GREEN" "✓ Vault unlocked (valid for this session)"
        msg "$YELLOW" "  To persist in your shell, run:"
        msg "$YELLOW" "  export BW_SESSION=\"$BW_SESSION\""
    fi

    # Verify session is valid
    if ! bw unlock --check --session "$BW_SESSION" &>/dev/null; then
        msg "$YELLOW" "→ Session invalid or expired, unlocking vault..."
        # Clear old session before unlocking
        unset BW_SESSION
        export BW_SESSION="$(bw unlock --raw)" || {
            msg "$RED" "✗ Failed to unlock vault"
            return 1
        }
        msg "$GREEN" "✓ Vault unlocked"
        msg "$YELLOW" "  To persist in your shell, run:"
        msg "$YELLOW" "  export BW_SESSION=\"$BW_SESSION\""
    fi
}

# Get or create a Bitwarden item by name
get_or_create_item() {
    local item_name="$1"
    local item_id=$(bw list items --session "$BW_SESSION" 2>/dev/null | jq -r --arg name "$item_name" '.[] | select(.name == $name) | .id')

    if [[ -z "$item_id" ]]; then
        # Create the item and capture output
        local create_output=$(bw get template item | \
            jq '.type = 2 | .name = "'"$item_name"'" | .secureNote.type = 0' | \
            bw encode | bw create item --session "$BW_SESSION" 2>&1)

        # Extract item ID from output
        item_id=$(echo "$create_output" | jq -r '.id' 2>/dev/null)

        if [[ -z "$item_id" || "$item_id" == "null" ]]; then
            msg "$RED" "✗ Failed to create Bitwarden item: $item_name"
            msg "$RED" "  Error: $create_output"
            return 1
        fi
    fi

    echo "$item_id"
}

# Push secrets to Bitwarden
cmd_push() {
    if [[ ! -f "$SECRETS_REGISTRY" ]] || [[ ! -s "$SECRETS_REGISTRY" ]]; then
        msg "$RED" "✗ No secrets to push"
        msg "$YELLOW" "  Add secrets with: secrets add <path>"
        return 1
    fi

    # Verify all files exist
    local missing=0
    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue
        if [[ ! -e "$HOME/$path" ]]; then
            msg "$RED" "✗ Missing file: $path"
            ((missing++))
        fi
    done < "$SECRETS_REGISTRY"

    if [[ $missing -gt 0 ]]; then
        msg "$RED" "✗ Cannot push: $missing files missing"
        return 1
    fi

    ensure_bitwarden || return 1

    msg "$GREEN" "→ Creating tarball..."

    # Create tarball with all tracked files
    local temp_tar=$(mktemp /tmp/secrets.XXXXXX.tar.gz)
    trap "rm -f '$temp_tar'" EXIT

    # Read paths into array for tar
    local paths=()
    while IFS= read -r path; do
        [[ -z "$path" || "$path" =~ ^# ]] && continue
        paths+=("$path")
    done < "$SECRETS_REGISTRY"

    # Create tar from home directory
    tar czf "$temp_tar" -C "$HOME" "${paths[@]}" 2>/dev/null || {
        msg "$RED" "✗ Failed to create tarball"
        return 1
    }

    msg "$GREEN" "→ Encoding and chunking secrets..."

    # Base64 encode the tarball
    local base64_data=$(base64 < "$temp_tar" | tr -d '\n')
    local data_length=${#base64_data}
    local num_chunks=$(( (data_length + CHUNK_SIZE - 1) / CHUNK_SIZE ))

    msg "$GREEN" "  Data size: $data_length bytes"
    msg "$GREEN" "  Chunks needed: $num_chunks"

    # Delete old chunks if they exist
    msg "$YELLOW" "  Cleaning up old chunks..."
    local old_items=$(bw list items --session "$BW_SESSION" 2>/dev/null | \
        jq -r --arg prefix "$BW_ITEM_NAME_PREFIX - Chunk" '.[] | select(.name | startswith($prefix)) | .id')

    if [[ -n "$old_items" ]]; then
        while read -r old_id; do
            [[ -n "$old_id" ]] && bw delete item "$old_id" --session "$BW_SESSION" &>/dev/null
        done <<< "$old_items"
    fi

    # Create chunks
    msg "$YELLOW" "  Uploading chunks to Bitwarden..."
    for ((i=0; i<num_chunks; i++)); do
        local start=$((i * CHUNK_SIZE))
        local chunk="${base64_data:$start:$CHUNK_SIZE}"
        local chunk_name="$BW_ITEM_NAME_PREFIX - Chunk $i"

        # Create chunk item
        local chunk_id=$(get_or_create_item "$chunk_name")

        # Store chunk data
        bw get item "$chunk_id" --session "$BW_SESSION" | \
            jq --arg data "$chunk" '.notes = $data' | \
            bw encode | \
            bw edit item "$chunk_id" --session "$BW_SESSION" &>/dev/null

        msg "$GREEN" "    ✓ Chunk $((i+1))/$num_chunks"
    done

    # Create/update metadata item
    msg "$YELLOW" "  Storing metadata..."
    local metadata_id=$(get_or_create_item "$BW_METADATA_ITEM")
    local metadata_json=$(jq -n --arg count "$num_chunks" '{chunks: ($count | tonumber)}')

    bw get item "$metadata_id" --session "$BW_SESSION" | \
        jq --argjson meta "$metadata_json" '.notes = ($meta | tostring)' | \
        bw encode | \
        bw edit item "$metadata_id" --session "$BW_SESSION" &>/dev/null

    # Sync
    msg "$YELLOW" "  Syncing..."
    bw sync --session "$BW_SESSION" &>/dev/null

    msg "$GREEN" "✓ Secrets pushed to Bitwarden"
    msg "$GREEN" "  Files: ${#paths[@]}"
    msg "$GREEN" "  Chunks: $num_chunks"
    msg "$GREEN" "  Total size: $(du -h "$temp_tar" | cut -f1)"
}

# Pull secrets from Bitwarden
cmd_pull() {
    ensure_bitwarden || return 1

    msg "$GREEN" "→ Downloading metadata from Bitwarden..."

    # Get metadata item
    local metadata_data=$(bw get item "$BW_METADATA_ITEM" --session "$BW_SESSION" 2>&1)

    if [[ $? -ne 0 ]]; then
        msg "$RED" "✗ No secrets found in Bitwarden"
        msg "$YELLOW" "  Push secrets first with: secrets push"
        return 1
    fi

    # Parse metadata to get chunk count
    local metadata_json=$(echo "$metadata_data" | jq -r '.notes // empty')
    local num_chunks=$(echo "$metadata_json" | jq -r '.chunks // empty')

    if [[ -z "$num_chunks" || "$num_chunks" == "null" ]]; then
        msg "$RED" "✗ Invalid metadata in Bitwarden"
        msg "$YELLOW" "  Try pushing secrets again with: secrets push"
        return 1
    fi

    msg "$GREEN" "  Chunks to download: $num_chunks"

    # Download and concatenate all chunks
    msg "$YELLOW" "  Downloading chunks..."
    local base64_data=""
    for ((i=0; i<num_chunks; i++)); do
        local chunk_name="$BW_ITEM_NAME_PREFIX - Chunk $i"
        local chunk_data=$(bw get item "$chunk_name" --session "$BW_SESSION" 2>/dev/null | jq -r '.notes // empty')

        if [[ -z "$chunk_data" ]]; then
            msg "$RED" "✗ Failed to download chunk $i"
            return 1
        fi

        base64_data="${base64_data}${chunk_data}"
        msg "$GREEN" "    ✓ Chunk $((i+1))/$num_chunks"
    done

    # Decode and extract
    msg "$GREEN" "→ Extracting secrets..."
    echo "$base64_data" | base64 -d | tar xzf - -C "$HOME" || {
        msg "$RED" "✗ Failed to extract secrets"
        return 1
    }

    # Count files from registry if it exists
    local count=0
    if [[ -f "$SECRETS_REGISTRY" ]]; then
        count=$(grep -v '^#' "$SECRETS_REGISTRY" | grep -v '^$' | wc -l | tr -d ' ')
    fi

    msg "$GREEN" "✓ Secrets pulled from Bitwarden"
    [[ $count -gt 0 ]] && msg "$GREEN" "  Files restored: $count"
}

# Show help
cmd_help() {
    cat << 'EOF'
secrets - Manage dotfiles secrets with Bitwarden

Usage:
  secrets add <path>...      Add files/directories to secrets registry
  secrets remove <path>...   Remove from secrets registry
  secrets list               Show all tracked secrets
  secrets status             Show status of tracked files
  secrets push               Package and upload secrets to Bitwarden
  secrets pull               Download and restore secrets from Bitwarden
  secrets help               Show this help message

Examples:
  secrets add ~/.ssh/id_rsa ~/.env
  secrets add .aws/credentials
  secrets list
  secrets push
  secrets pull

Registry location: ~/.secrets
Bitwarden storage: Chunked base64 data across multiple secure notes
  - Metadata: "Dotfiles Secrets - Metadata" (tracks chunk count)
  - Chunks: "Dotfiles Secrets - Chunk 0", "Chunk 1", etc.
  - Works with free Bitwarden tier (10k char limit per note)
EOF
}

# Main command router
main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        add)
            cmd_add "$@"
            ;;
        remove|rm)
            cmd_remove "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        status|st)
            cmd_status "$@"
            ;;
        push)
            cmd_push "$@"
            ;;
        pull)
            cmd_pull "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            msg "$RED" "✗ Unknown command: $cmd"
            echo ""
            cmd_help
            return 1
            ;;
    esac
}

main "$@"
